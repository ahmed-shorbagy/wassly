import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:dartz/dartz.dart';
import '../../../../core/constants/app_constants.dart';
import '../../../../core/errors/exceptions.dart';
import '../../../../core/errors/failures.dart';
import '../../../../core/utils/logger.dart';
import '../../domain/entities/delivery_address_entity.dart';
import '../../domain/repositories/delivery_address_repository.dart';
import '../models/delivery_address_model.dart';

class DeliveryAddressRepositoryImpl implements DeliveryAddressRepository {
  final FirebaseFirestore firestore;

  DeliveryAddressRepositoryImpl({required this.firestore});

  CollectionReference<Map<String, dynamic>> _userAddressesCol(String userId) {
    return firestore
        .collection(AppConstants.usersCollection)
        .doc(userId)
        .collection('delivery_addresses');
  }

  @override
  Future<Either<Failure, DeliveryAddressEntity?>> getCurrentDeliveryAddress(
    String userId,
  ) async {
    try {
      AppLogger.logInfo('Fetching current delivery address for user: $userId');

      // Get the default address (isDefault = true)
      final snapshot = await _userAddressesCol(userId)
          .where('isDefault', isEqualTo: true)
          .limit(1)
          .get();

      if (snapshot.docs.isEmpty) {
        AppLogger.logWarning('No delivery address found for user: $userId');
        return const Right(null);
      }

      final address =
          DeliveryAddressModel.fromFirestore(snapshot.docs.first);
      AppLogger.logSuccess(
        'Delivery address found: ${address.address}',
      );
      return Right(address);
    } on FirebaseException catch (e) {
      AppLogger.logError(
        'Firebase error fetching delivery address',
        error: e,
      );
      return Left(ServerFailure('Failed to fetch address: ${e.message}'));
    } catch (e) {
      AppLogger.logError('Error fetching delivery address', error: e);
      return Left(ServerFailure('Failed to fetch address'));
    }
  }

  @override
  Stream<DeliveryAddressEntity?> streamCurrentDeliveryAddress(
    String userId,
  ) {
    try {
      return _userAddressesCol(userId)
          .where('isDefault', isEqualTo: true)
          .limit(1)
          .snapshots()
          .map((snapshot) {
        if (snapshot.docs.isEmpty) {
          return null;
        }
        return DeliveryAddressModel.fromFirestore(snapshot.docs.first);
      });
    } catch (e) {
      AppLogger.logError(
        'Error streaming delivery address',
        error: e,
      );
      throw ServerException('Failed to stream address: ${e.toString()}');
    }
  }

  @override
  Future<Either<Failure, void>> setCurrentDeliveryAddress(
    String userId,
    String address,
    String? addressLabel,
  ) async {
    try {
      AppLogger.logInfo('Setting delivery address for user: $userId');

      // For now, use a default location (user can update later with map)
      // This should ideally come from geocoding the address
      const defaultLocation = GeoPoint(30.0444, 31.2357); // Cairo, Egypt

      final now = DateTime.now();
      final addressData = DeliveryAddressModel(
        id: '', // Will be generated by Firestore
        userId: userId,
        address: address,
        addressLabel: addressLabel,
        location: defaultLocation,
        isDefault: true,
        createdAt: now,
        updatedAt: now,
      ).toFirestore();

      // Set all existing addresses to not default
      final existingSnapshot =
          await _userAddressesCol(userId).where('isDefault', isEqualTo: true).get();
      
      for (final doc in existingSnapshot.docs) {
        await doc.reference.update({'isDefault': false});
      }

      // Add or update the default address
      // Use a fixed document ID for the default address (makes it easier to update)
      await _userAddressesCol(userId).doc('default').set(addressData, SetOptions(merge: true));

      AppLogger.logSuccess('Delivery address set successfully');
      return const Right(null);
    } on FirebaseException catch (e) {
      AppLogger.logError(
        'Firebase error setting delivery address',
        error: e,
      );
      return Left(ServerFailure('Failed to set address: ${e.message}'));
    } catch (e) {
      AppLogger.logError('Error setting delivery address', error: e);
      return Left(ServerFailure('Failed to set address'));
    }
  }

  @override
  Future<Either<Failure, void>> clearCurrentDeliveryAddress(
    String userId,
  ) async {
    try {
      AppLogger.logInfo('Clearing delivery address for user: $userId');

      // Delete the default address
      await _userAddressesCol(userId).doc('default').delete();

      AppLogger.logSuccess('Delivery address cleared successfully');
      return const Right(null);
    } on FirebaseException catch (e) {
      AppLogger.logError(
        'Firebase error clearing delivery address',
        error: e,
      );
      return Left(ServerFailure('Failed to clear address: ${e.message}'));
    } catch (e) {
      AppLogger.logError('Error clearing delivery address', error: e);
      return Left(ServerFailure('Failed to clear address'));
    }
  }
}

